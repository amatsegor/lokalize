package lokalize.transformer

import lokalize.models.*

abstract class AbstractTransformer {

    open fun transformArray(array: LSArray): String = ""

    open fun transformPlural(plural: LSPlural): String = ""

    abstract fun transformComment(comment: String): String

    abstract fun transformKeyValue(key: String, value: String, closing: Boolean): String

    abstract fun insert(input: String?, newValues: String, options: Options): String

    fun transform(entities: List<LSEntity>): String {
        val valueToInsert = StringBuilder()

        val nonEmptyEntities = entities.filter { entity -> !entity.isEmpty }

        nonEmptyEntities
                .sortedWith(ENTITY_COMPARATOR)
                .forEachIndexed { index, entity ->
                    var skipped = false

                    val isClosing = index == nonEmptyEntities.size - 1

                    when (entity) {
                        is LSLine -> appendLine(entity, valueToInsert, isClosing)
                        is LSArray -> skipped = appendArray(entity, valueToInsert, skipped)
                        is LSPlural -> skipped = appendPlural(entity, valueToInsert, skipped)
                    }

                    if (!isClosing && !skipped) {
                        valueToInsert.append('\n')
                    }
                }
        return valueToInsert.toString()
    }

    private fun appendLine(entity: LSLine, target: StringBuilder, isClosing: Boolean) {
        if (entity.isComment) {
            target.append(transformComment(entity.value))
        } else {
            target.append(transformKeyValue(entity.key, entity.value, isClosing))
        }
    }

    private fun appendArray(array: LSArray, target: StringBuilder, skipped: Boolean): Boolean {
        var isSkipped = skipped
        val transformedArray = transformArray(array)

        if (transformedArray.isBlank()) {
            isSkipped = true
        } else {
            target.append(transformedArray)
        }
        return isSkipped
    }

    private fun appendPlural(plural: LSPlural, target: StringBuilder, skipped: Boolean): Boolean {
        var isSkipped = skipped
        val transformedPlural = transformPlural(plural)

        if (transformedPlural.isBlank()) {
            isSkipped = true
        } else {
            target.append(transformedPlural)
        }
        return isSkipped
    }

    abstract val autogeneratedTag: String

    companion object {
        private val ENTITY_COMPARATOR = Comparator<LSEntity> { e1, e2 ->
            return@Comparator if (e1 is LSArray) {
                if (e2 is LSArray) 0 else -1
            } else {
                if (e2 is LSArray) 1 else 0
            }
        }
    }
}